package fr.vergne.benchmark.event.impl;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

import fr.vergne.benchmark.BenchmarkRunner;
import fr.vergne.benchmark.Link;
import fr.vergne.benchmark.Task;
import fr.vergne.benchmark.event.BenchmarkEvent;
import fr.vergne.benchmark.event.BenchmarkEventListener;
import fr.vergne.benchmark.event.LinkTransferedEvent;
import fr.vergne.benchmark.event.TaskExecutedEvent;
import fr.vergne.benchmark.event.TaskFailedEvent;
import fr.vergne.benchmark.event.TaskSelectedEvent;
import fr.vergne.benchmark.impl.SyncLink;
import fr.vergne.logging.LoggerConfiguration;

/**
 * This {@link TraceListener} is a {@link BenchmarkEventListener} which keeps
 * trace of all the events generated by the {@link BenchmarkRunner} it is
 * related to. Each execution of a {@link Task} is represented by a
 * {@link TaskExecution} which provides the properties of the execution and
 * describes how it is related to other {@link TaskExecution}s.
 * 
 * @author Matthieu Vergne <matthieu.vergne@gmail.com>
 * 
 */
// FIXME test
public class TraceListener implements BenchmarkEventListener {

	/**
	 * {@link TaskExecution} from which the traces start (no trace of previous
	 * execution leading to them is available).
	 */
	private final Collection<TaskExecution> starts = new LinkedList<TaskExecution>();
	/**
	 * All the {@link TaskExecution} which have been actually executed.
	 */
	private final Collection<TaskExecution> executed = new LinkedList<TaskExecution>();
	/**
	 * A set of {@link TaskExecution} which are expected to be executed in the
	 * future.
	 */
	private final Collection<TaskExecution> prepared = new LinkedList<TaskExecution>();
	public final Logger logger = LoggerConfiguration.getSimpleLogger();

	@Override
	public void eventGenerated(BenchmarkEvent event) {
		if (event instanceof TaskSelectedEvent) {
			Task task = ((TaskSelectedEvent) event).getTask();
			TaskExecution wrapper = retrieve(prepared, task);
			if (wrapper == null) {
				wrapper = new TaskExecution(task);
				starts.add(wrapper);
				prepared.add(wrapper);
			} else {
				// already planned
			}
			wrapper.setSelectionTime(getCurrentTime());
		} else if (event instanceof TaskExecutedEvent) {
			Task task = ((TaskExecutedEvent) event).getTask();
			terminateTask(task, ExecutionState.SUCCESS);
		} else if (event instanceof TaskFailedEvent) {
			Task task = ((TaskFailedEvent) event).getTask();
			terminateTask(task, ExecutionState.FAILURE);
		} else if (event instanceof LinkTransferedEvent) {
			Link<?> link = ((LinkTransferedEvent) event).getLink();
			Task sourceTask = link.getSourceTask();
			Task targetTask = link.getTargetTask();
			TaskExecution sourceWrapper = retrieve(executed, sourceTask);
			TaskExecution targetWrapper = plan(targetTask);
			targetWrapper.setExecutionState(ExecutionState.NOT_EXECUTED);
			if (sourceWrapper == null) {
				logger.warning("Untraced execution of " + sourceTask);
				sourceWrapper = new TaskExecution(sourceTask);
				starts.add(sourceWrapper);
				executed.add(sourceWrapper);
			} else {
				sourceWrapper.addNext(targetWrapper);
			}
			targetWrapper.setInput(
					link instanceof SyncLink ? ((SyncLink<?>) link)
							.getSourceId() : null, link.getValue(),
					sourceWrapper);
		} else {
			logger.warning("Unmanaged event: " + event);
		}
	}

	/**
	 * When this {@link TraceListener} starts to trace the
	 * {@link BenchmarkEvent}s, some {@link Task}s are executed before any
	 * other. As each {@link TaskExecution} provides the {@link TaskExecution}s
	 * which (are supposed to) follow, the first {@link TaskExecution}s are not
	 * provided by any other. This method provides them. This way, one can start
	 * from a minimal set of {@link TaskExecution}s to explore to full traces.
	 * 
	 * @return the traces of the starting {@link Task}s
	 */
	public List<TaskExecution> getTracesStart() {
		return new LinkedList<TaskExecution>(starts);
	}

	/**
	 * This method aims at providing the traces of the {@link Task}s which have
	 * been already executed. The {@link TaskExecution} of a newly selected
	 * {@link Task} not yet executed is not returned here, but remains
	 * accessible through the {@link TaskExecution}s of the previously executed
	 * {@link Task}s it depends on.
	 * 
	 * @return the execution traces
	 */
	public List<TaskExecution> getTracesExecuted() {
		return new LinkedList<TaskExecution>(executed);
	}

	/**
	 * When a {@link Task} is executed and its outputs are transfered to inputs
	 * of other {@link Task}s, these other {@link Task}s are expected to be
	 * executed later. This {@link TraceListener} prepares the corresponding
	 * {@link TaskExecution}s in advance to have them ready when they will be
	 * executed. This method returns these prepared {@link TaskExecution}s.
	 * 
	 * @return the expected future traces
	 */
	public List<TaskExecution> getTracesPrepared() {
		return new LinkedList<TaskExecution>(prepared);
	}

	/**
	 * This method aims at being the union of all the other methods which
	 * provide traces. If one want to do a complete analysis of the available
	 * data, this method can be used. One can also use {@link #getTracesStart()}
	 * to start with a minimal set of {@link TaskExecution}s, but then needs to
	 * explore the traces manually.
	 * 
	 * @return the full trace
	 */
	public List<TaskExecution> getTraces() {
		List<TaskExecution> traces = new LinkedList<TaskExecution>();
		traces.addAll(executed);
		traces.addAll(prepared);
		return traces;
	}

	private long getCurrentTime() {
		return System.currentTimeMillis();
	}

	private void terminateTask(Task task, ExecutionState state) {
		TaskExecution wrapper = retrieve(prepared, task);
		if (wrapper == null) {
			logger.warning("Unplanned execution of " + task);
			wrapper = new TaskExecution(task);
			starts.add(wrapper);
		} else {
			prepared.remove(wrapper);
		}
		wrapper.setExecutionState(state);
		wrapper.setExecutionTime(getCurrentTime());
		for (Object id : task.getOutputIds()) {
			wrapper.setOutput(id, task.getOutput(id));
		}
		executed.add(wrapper);
	}

	private TaskExecution plan(Task task) {
		for (TaskExecution wrapper : prepared) {
			if (wrapper.getTask() == task) {
				return wrapper;
			} else {
				continue;
			}
		}
		TaskExecution wrapper = new TaskExecution(task);
		prepared.add(wrapper);
		return wrapper;
	}

	private TaskExecution retrieve(Collection<TaskExecution> collection,
			Task task) {
		for (TaskExecution wrapper : collection) {
			if (wrapper.getTask() == task) {
				return wrapper;
			} else {
				continue;
			}
		}
		return null;
	}

	/**
	 * A {@link TaskExecution} describes a single execution of a single
	 * {@link Task}. In particular, it tells when the {@link Task} has been
	 * selected and executed, the result of the execution and which outputs have
	 * been used as inputs for other {@link TaskExecution}s.
	 * 
	 * @author Matthieu Vergne <matthieu.vergne@gmail.com>
	 * 
	 */
	public static class TaskExecution implements Comparable<TaskExecution> {
		private final Task task;
		private final Map<Long, TaskExecution> nexts = new LinkedHashMap<Long, TaskExecution>();
		private ExecutionState executionState = ExecutionState.UNKNOWN;
		private Long executionTime = null;
		private Long selectionTime = null;
		private final Map<Object, InputDescriptor> inputs = new HashMap<Object, InputDescriptor>();
		private final Map<Object, Object> outputs = new HashMap<Object, Object>();

		public TaskExecution(Task task) {
			this.task = task;
		}

		/**
		 * 
		 * @return the {@link Task} executed for this {@link TaskExecution}
		 */
		public Task getTask() {
			return task;
		}

		public void addNext(TaskExecution next) {
			nexts.put(System.currentTimeMillis(), next);
		}

		/**
		 * Notice that the outputs of a {@link Task} are transfered to the
		 * inputs of other {@link Task}s, which lead to expect these latter
		 * {@link Task}s to be executed. Consequently, some additional
		 * {@link TaskExecution}s are prepared before to have their actual
		 * execution. This method returns them in addition to the actually
		 * executed ones.
		 * 
		 * @return the set of {@link TaskExecution}s which follow directly this
		 *         one.
		 */
		public Map<Long, TaskExecution> getNexts() {
			return nexts;
		}

		public void setSelectionTime(long selectionTime) {
			this.selectionTime = selectionTime;
		}

		/**
		 * 
		 * @return the timestamp of the selection of this {@link Task}
		 */
		public Long getSelectionTime() {
			return selectionTime;
		}

		public void setExecutionTime(long time) {
			this.executionTime = time;
		}

		/**
		 * 
		 * @return the timestamp of the execution of this {@link Task}
		 */
		public Long getExecutionTime() {
			return executionTime;
		}

		public void setExecutionState(ExecutionState state) {
			this.executionState = state;
		}

		/**
		 * 
		 * @return the {@link ExecutionState} describing the behavior of this
		 *         {@link Task}
		 */
		public ExecutionState getExecutionState() {
			return executionState;
		}

		public void setInput(Object id, Object value, TaskExecution source) {
			inputs.put(id, new InputDescriptor(source, TaskExecution.this, id,
					value));
		}

		/**
		 * 
		 * @return the description of the inputs used by this {@link Task}
		 *         during its execution.
		 */
		public Map<Object, InputDescriptor> getInputs() {
			return Collections.unmodifiableMap(inputs);
		}

		public void setOutput(Object id, Object value) {
			outputs.put(id, value);
		}

		/**
		 * 
		 * @return the outputs generated by this {@link Task} during its
		 *         execution.
		 */
		public Map<Object, Object> getOutputs() {
			return Collections.unmodifiableMap(outputs);
		}

		@Override
		public int compareTo(TaskExecution w) {
			Long t1 = notNull(selectionTime);
			Long t2 = notNull(w.selectionTime);
			return t1.compareTo(t2);
		}

		private long notNull(Long t) {
			return t == null ? Long.MAX_VALUE : t;
		}
	}

	/**
	 * This class centralizes the information about a specific input.
	 * 
	 * @author Matthieu Vergne <matthieu.vergne@gmail.com>
	 * 
	 */
	public static class InputDescriptor {
		private final Object id;
		private final Object value;
		private final TaskExecution source;
		private final TaskExecution task;

		public InputDescriptor(TaskExecution source, TaskExecution task,
				Object id, Object value) {
			this.source = source;
			this.task = task;
			this.id = id;
			this.value = value;
		}

		/**
		 * 
		 * @return the {@link TaskExecution} which uses this input
		 */
		public TaskExecution getTask() {
			return task;
		}

		/**
		 * 
		 * @return the ID of the input
		 */
		public Object getId() {
			return id;
		}

		/**
		 * 
		 * @return the value of the input
		 */
		public Object getValue() {
			return value;
		}

		/**
		 * 
		 * @return the execution which has provided this input
		 */
		public TaskExecution getSource() {
			return source;
		}
	}

	public static enum ExecutionState {
		/**
		 * The {@link Task} has not been executed yet.
		 */
		NOT_EXECUTED,
		/**
		 * The {@link Task} has been executed successfully.
		 */
		SUCCESS,
		/**
		 * The {@link Task} has been interrupted before to finish.
		 */
		FAILURE,
		/**
		 * Unknown state. The task could have been executed or not, and if yes
		 * it could have failed or not.
		 */
		UNKNOWN
	}
}
